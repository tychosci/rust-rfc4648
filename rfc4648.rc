/*!
rfc4648 - RFC 4648: Base16, Base32, Base64 Data Encodings
*/
#[link(name = "rfc4648",
       vers = "0.1",
       uuid = "7F7C9B2E-84D6-484F-BBD5-96A2076BDC32",
       url  = "https://github.com/tychosci/rust-rfc4648")];

#[comment = "RFC 4648: Base16, Base32, Base64 Data Encodings"];
#[license = "MIT license"];
#[crate_type = "lib"];

extern mod std;

pub mod base16;
pub mod base32;
pub mod base64;
mod util;

pub trait ToBase16 {
    fn to_base16(&self) -> ~[u8];
}

pub trait ToBase32 {
    fn to_base32(&self) -> ~[u8];
    fn to_base32_hex(&self) -> ~[u8];
}

pub trait ToBase64 {
    fn to_base64(&self) -> ~[u8];
    fn to_base64_urlsafe(&self) -> ~[u8];
}

pub trait FromBase16<T> {
    fn from_base16(&self) -> T;
}

pub trait FromBase32<T> {
    fn from_base32(&self) -> T;
    fn from_base32_hex(&self) -> T;
}

pub trait FromBase64<T> {
    fn from_base64(&self) -> T;
    fn from_base64_urlsafe(&self) -> T;
}

pub trait Rfc4648<T>:
    FromBase16<T> FromBase32<T> FromBase64<T>
    ToBase16 ToBase32 ToBase64 {
}

pub impl &[const u8]: Rfc4648<~[u8]>;
pub impl &str: Rfc4648<~[u8]>;

pub impl &[const u8]: ToBase16 {
    fn to_base16(&self) -> ~[u8] {
        base16::encode(*self)
    }
}

pub impl &[const u8]: ToBase32 {
    fn to_base32(&self) -> ~[u8] {
        base32::encode(*self)
    }
    fn to_base32_hex(&self) -> ~[u8] {
        base32::hex_encode(*self)
    }
}

pub impl &[const u8]: ToBase64 {
    fn to_base64(&self) -> ~[u8] {
        base64::encode(*self)
    }
    fn to_base64_urlsafe(&self) -> ~[u8] {
        base64::urlsafe_encode(*self)
    }
}

pub impl &[const u8]: FromBase16<~[u8]> {
    fn from_base16(&self) -> ~[u8] {
        base16::decode(*self)
    }
}

pub impl &[const u8]: FromBase32<~[u8]> {
    fn from_base32(&self) -> ~[u8] {
        base32::decode(*self)
    }
    fn from_base32_hex(&self) -> ~[u8] {
        base32::hex_decode(*self)
    }
}

pub impl &[const u8]: FromBase64<~[u8]> {
    fn from_base64(&self) -> ~[u8] {
        base64::decode(*self)
    }
    fn from_base64_urlsafe(&self) -> ~[u8] {
        base64::urlsafe_decode(*self)
    }
}

macro_rules! mk_impl_for_str_to(
    ($trait_name:ident, [$($method_name:ident),+]) => (
        pub impl &str: $trait_name {
            $(fn $method_name(&self) -> ~[u8] {
                str::byte_slice(*self, |b| b.$method_name())
            })+
        }
    )
)
macro_rules! mk_impl_for_str_from(
    ($trait_name:ident, [$($method_name:ident),+]) => (
        pub impl &str: $trait_name<~[u8]> {
            $(fn $method_name(&self) -> ~[u8] {
                str::byte_slice(*self, |b| b.$method_name())
            })+
        }
    )
)
mk_impl_for_str_to!(ToBase16, [to_base16])
mk_impl_for_str_to!(ToBase32, [to_base32, to_base32_hex])
mk_impl_for_str_to!(ToBase64, [to_base64, to_base64_urlsafe])
mk_impl_for_str_from!(FromBase16, [from_base16])
mk_impl_for_str_from!(FromBase32, [from_base32, from_base32_hex])
mk_impl_for_str_from!(FromBase64, [from_base64, from_base64_urlsafe])
